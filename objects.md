# Базовые понятия

        let user = new Object() // создание объекта и сохранение в переменную

        user.name = "anton";  // добавляем свойства через конструктор
        user.age = 20  // и т.д.

- чтобы вывести в консоль конкретное свойство, запишем так:

        console.log(user.name);

- можно создать объект через литералл объекта:

        user = {}  // запись литералла объекта, так проще создать объект
        
        // запишем сразу свойства, так быстрее и проще создать объект чем через конструктор
        user = {
            name: "anton",
            age: 20
        }

- можно переприсвоить значение свойства следующим образом:

        user['age']  // покажет текущее значение
        user['age'] = 25;  // переприсвоили с 20 на 25
        user['a' + 'ge'] = 25  // можно и так))

- если мы попытаемся прочитать свойство которого нет, то получим значение undefind:

        user.newName  // результат undefind

- но если мы сразу присвоим ему значение, то такое свойство появится

        user.newName = "result"  // в результате к имеющимся свойствам name и age добавилось newName с значением result

- аналогично с квадратными скобками:

        user["newName"]  // результат undefind
        user["newName"] = 123  // результат - 123

- функцию можно записать вот так через конструктор:

      new Function('a', 'b', 'return a + b')

другие примеры:

    let customProperty = "isCat";
    {
      name: "igor",
      age: 23,
      [customProperty]: false,
      ['ma' + 'ma']: false,
    }  // результат - {name: 'igor', age: 23, isCat: false, mama: false}

код выше можно записать в переменную и обращаться к свойствам по имени:

    
    let customProperty = "isCat";
    let user = {
      name: "igor",
      age: 23,
      [customProperty]: false,
      ['ma' + 'ma']: false,
    }

Если перебрать циклом, то мы увидим все свойства объекта:

    for(let property in user){
      console.log(property);
    }  // результат name, age, isCat, mama

если нам нужно обратиться к конкретному свойству, то нужно использовать запись в квадратных скобках, тогда увидим название свойства и его значение:

    for(let property in user){
      console.log(property, user[property]);
    }  // результат name igor и т.д.

## Оператор опциональной последовательности **?.**:

пример записи:

    user?.fio?.first?.name

запись выше - заменяет устаревшую запись с дублированием:

    user && user.fio && user.fio.first && user.fio.first.name


# Spread, rest, деструкторизация

**spread** - используется для того чтобы разделить значения массива на отдельные составляющие.

Пример:

    let arr = [2, 3, 4, 5];
    ["2", "4", "5", arr]  // здесь нет spred оператораб поэтому в массив добавиться вложенный массив arr
    ["2", "4", "5", ...arr]  // ... - spred операторб результат: ["2", "4", "5", 2, 3, 4, 5]
    [...arr, "2", "4", "5", ...arr]  // результат [2, 3, 4, 5, "2", "4", "5", 2, 3, 4, 5]

**Math.max** и **Math.min** - функции, принимающие аргументом набор значений и возвращают либо максимальное, либо минимальное из них.

    Math.max(3,5,7,10,100,999,4);
    999

    Math.min(3,5,7,10,100,999,4);
    3

сгенерируем случайный массив чисел и отфильтруем с помощью **Math.max**

    let arr = []; // создали пустой массив
    for(let i = 0, i < 15; i++){  // заполним его через цикл в 15 элементов
        arr.push(Math.round(Math.random()*100));  // округлим **round** случайное **random** число умножив его на 100 для удобства и запишем в массив
    };

результат:

    arr
    (15) [74, 41, 91, 17, 1, 11, 17, 46, 45, 36, 40, 78, 92, 3, 23]

отфильтруем по максимальному значению использую оператор **spread**

    Math.max(...arr);  // результат - 92

**Деструктуризация** - используется для того, чтобы разделить элементы и переформировать их сохраняя элементы в какие-то значения.

можно присваивать элементы массива переменным в таком виде:

    let firstElement = arr[0];
    let secondElement = arr[1];
    let thirdElement = arr[2];

но быстрееб проще и удобнее **деструктурировать** так:

    let [firstElement, secondElement, thirdElement] = arr;
    
    let [firstElement, secondElement, thirdElement, ...other] = arr;  // а так можно части переменных присвоить конкретные значения, а остальные записать массиваом в другую переменнуюб как бы разделяя

**Деструктуризация** объекта:

    let user = {name: "Petr", age: 23}
    let {name, age} = user;

в некоторых случаях можно записать и так:

    let {name: userName, age: userAge} = user;

**Деструктуризация** в аргументах функций:

    function showUserName(user) {
      console.log(user.name);
    }
    
    showUserName({name: "Ivan"})  // результат: "Ivan", без дистриктуризации

**А теперь через дистрикутризацию:**

    function showUserName({name}) {
      console.log(name);
    }
    
    showUserName({name: "Ivan"})  // результат: "Ivan", но уже через дистриктуризацию

# Удаление свойств и объектов

Конструкция **delete**

    let user = {name: "kiril", age: 34};
    undefined
    delete user.age
    true
    user
    {name: 'kiril'}
    delete user.age
    true
    let arr = [1, 3,4,45,6,7]
    undefined
    delete arr.length
    false
    delete arr[3]
    true
    arr.length
    6
    arr
    (6) [1, 3, 4, empty, 6, 7]


# Функции-конструкторы, свойство *prototype*

